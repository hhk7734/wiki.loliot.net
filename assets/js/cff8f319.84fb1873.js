"use strict";(self.webpackChunkwiki_loliot_net=self.webpackChunkwiki_loliot_net||[]).push([[34309],{7227:(n,e,l)=>{l.d(e,{A:()=>r});l(96540);var t=l(34164);const c={tabItem:"tabItem_Ymn6"};var o=l(74848);function r({children:n,hidden:e,className:l}){return(0,o.jsx)("div",{role:"tabpanel",className:(0,t.A)(c.tabItem,l),hidden:e,children:n})}},28453:(n,e,l)=>{l.d(e,{R:()=>r,x:()=>a});var t=l(96540);const c={},o=t.createContext(c);function r(n){const e=t.useContext(o);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(c):n.components||c:r(n.components),t.createElement(o.Provider,{value:e},n.children)}},49489:(n,e,l)=>{l.d(e,{A:()=>v});var t=l(96540),c=l(34164),o=l(24245),r=l(56347),a=l(36494),i=l(62814),s=l(67548),u=l(69900);function _(n){return t.Children.toArray(n).filter(n=>"\n"!==n).map(n=>{if(!n||(0,t.isValidElement)(n)&&function(n){const{props:e}=n;return!!e&&"object"==typeof e&&"value"in e}(n))return n;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof n.type?n.type:n.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function f(n){const{values:e,children:l}=n;return(0,t.useMemo)(()=>{const n=e??function(n){return _(n).map(({props:{value:n,label:e,attributes:l,default:t}})=>({value:n,label:e,attributes:l,default:t}))}(l);return function(n){const e=(0,s.XI)(n,(n,e)=>n.value===e.value);if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map(n=>n.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(n),n},[e,l])}function d({value:n,tabValues:e}){return e.some(e=>e.value===n)}function p({queryString:n=!1,groupId:e}){const l=(0,r.W6)(),c=function({queryString:n=!1,groupId:e}){if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!e)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return e??null}({queryString:n,groupId:e});return[(0,i.aZ)(c),(0,t.useCallback)(n=>{if(!c)return;const e=new URLSearchParams(l.location.search);e.set(c,n),l.replace({...l.location,search:e.toString()})},[c,l])]}function L(n){const{defaultValue:e,queryString:l=!1,groupId:c}=n,o=f(n),[r,i]=(0,t.useState)(()=>function({defaultValue:n,tabValues:e}){if(0===e.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!d({value:n,tabValues:e}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${e.map(n=>n.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const l=e.find(n=>n.default)??e[0];if(!l)throw new Error("Unexpected error: 0 tabValues");return l.value}({defaultValue:e,tabValues:o})),[s,_]=p({queryString:l,groupId:c}),[L,m]=function({groupId:n}){const e=function(n){return n?`docusaurus.tab.${n}`:null}(n),[l,c]=(0,u.Dv)(e);return[l,(0,t.useCallback)(n=>{e&&c.set(n)},[e,c])]}({groupId:c}),C=(()=>{const n=s??L;return d({value:n,tabValues:o})?n:null})();(0,a.A)(()=>{C&&i(C)},[C]);return{selectedValue:r,selectValue:(0,t.useCallback)(n=>{if(!d({value:n,tabValues:o}))throw new Error(`Can't select invalid tab value=${n}`);i(n),_(n),m(n)},[_,m,o]),tabValues:o}}var m=l(11062);const C={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var E=l(74848);function N({className:n,block:e,selectedValue:l,selectValue:t,tabValues:r}){const a=[],{blockElementScrollPositionUntilNextRender:i}=(0,o.a_)(),s=n=>{const e=n.currentTarget,c=a.indexOf(e),o=r[c].value;o!==l&&(i(e),t(o))},u=n=>{let e=null;switch(n.key){case"Enter":s(n);break;case"ArrowRight":{const l=a.indexOf(n.currentTarget)+1;e=a[l]??a[0];break}case"ArrowLeft":{const l=a.indexOf(n.currentTarget)-1;e=a[l]??a[a.length-1];break}}e?.focus()};return(0,E.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.A)("tabs",{"tabs--block":e},n),children:r.map(({value:n,label:e,attributes:t})=>(0,E.jsx)("li",{role:"tab",tabIndex:l===n?0:-1,"aria-selected":l===n,ref:n=>{a.push(n)},onKeyDown:u,onClick:s,...t,className:(0,c.A)("tabs__item",C.tabItem,t?.className,{"tabs__item--active":l===n}),children:e??n},n))})}function b({lazy:n,children:e,selectedValue:l}){const o=(Array.isArray(e)?e:[e]).filter(Boolean);if(n){const n=o.find(n=>n.props.value===l);return n?(0,t.cloneElement)(n,{className:(0,c.A)("margin-top--md",n.props.className)}):null}return(0,E.jsx)("div",{className:"margin-top--md",children:o.map((n,e)=>(0,t.cloneElement)(n,{key:e,hidden:n.props.value!==l}))})}function g(n){const e=L(n);return(0,E.jsxs)("div",{className:(0,c.A)("tabs-container",C.tabList),children:[(0,E.jsx)(N,{...e,...n}),(0,E.jsx)(b,{...e,...n})]})}function v(n){const e=(0,m.A)();return(0,E.jsx)(g,{...n,children:_(n.children)},String(e))}},70509:(n,e,l)=>{l.r(e),l.d(e,{assets:()=>u,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>t,toc:()=>_});const t=JSON.parse('{"id":"lang/cpp/libraries/opencl/opencl-example","title":"OpenCL Example","description":"OpenCL Example","source":"@site/docs/lang/cpp/libraries/opencl/opencl-example.mdx","sourceDirName":"lang/cpp/libraries/opencl","slug":"/lang/cpp/libraries/opencl/opencl-example","permalink":"/docs/lang/cpp/libraries/opencl/opencl-example","draft":false,"unlisted":false,"editUrl":"https://github.com/hhk7734/wiki/tree/main/docs/lang/cpp/libraries/opencl/opencl-example.mdx","tags":[],"version":"current","lastUpdatedAt":1703257929000,"frontMatter":{"id":"opencl-example","title":"OpenCL Example","sidebar_label":"Example","description":"OpenCL Example","keywords":["C++","OpenCL","Mali","SAXPY"]},"sidebar":"cpp","previous":{"title":"OpenCL with Mali GPU","permalink":"/docs/lang/cpp/libraries/opencl/opencl-with-mali-gpu"},"next":{"title":"Installation","permalink":"/docs/lang/cpp/libraries/opencv/opencv-installation"}}');var c=l(74848),o=l(28453),r=l(49489),a=l(7227);const i={id:"opencl-example",title:"OpenCL Example",sidebar_label:"Example",description:"OpenCL Example",keywords:["C++","OpenCL","Mali","SAXPY"]},s=void 0,u={},_=[{value:"Platform informations",id:"platform-informations",level:2},{value:"SAXPY, CPU vs. GPU or Mali-GPU",id:"saxpy-cpu-vs-gpu-or-mali-gpu",level:2}];function f(n){const e={code:"code",h2:"h2",pre:"pre",...(0,o.R)(),...n.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(e.h2,{id:"platform-informations",children:"Platform informations"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-cpp",metastring:'title="get_info.cpp"',children:'#include <CL/cl.h>\n#include <cstdlib>\n#include <iostream>\n\nusing namespace std;\n\nint main(void) {\n    cl_int  status;\n    size_t  str_info_size;\n    char *  str_info;\n    cl_uint uint_info;\n\n    cl_uint         num_platforms;\n    cl_platform_id *platforms;\n\n    cl_uint       num_devices;\n    cl_device_id *devices;\n\n    status = clGetPlatformIDs(0, NULL, &num_platforms);\n    if(status != CL_SUCCESS) {\n        cerr << "Failed to get the number of platforms." << endl;\n        return -1;\n    }\n\n    if(num_platforms > 0) {\n        cout << "* The number of platforms: " << num_platforms << endl;\n    } else {\n        cerr << "The number of platforms is zero." << endl;\n        return -1;\n    }\n\n    platforms\n        = (cl_platform_id *)malloc(sizeof(cl_platform_id) * num_platforms);\n    clGetPlatformIDs(num_platforms, platforms, NULL);\n\n    for(int i = 0; i < num_platforms; ++i) {\n        cout << "  -----------------------------------------------" << endl;\n        cout << "  Platform-" << i + 1 << endl;\n\n        clGetPlatformInfo(\n            platforms[i], CL_PLATFORM_NAME, 0, NULL, &str_info_size);\n        str_info = (char *)malloc(str_info_size);\n        clGetPlatformInfo(\n            platforms[i], CL_PLATFORM_NAME, str_info_size, str_info, NULL);\n        cout << "  * Platform: " << str_info << endl;\n        free(str_info);\n\n        clGetPlatformInfo(\n            platforms[i], CL_PLATFORM_PROFILE, 0, NULL, &str_info_size);\n        str_info = (char *)malloc(str_info_size);\n        clGetPlatformInfo(\n            platforms[i], CL_PLATFORM_PROFILE, str_info_size, str_info, NULL);\n        cout << "  * Profile: " << str_info << endl;\n        free(str_info);\n\n        clGetPlatformInfo(\n            platforms[i], CL_PLATFORM_VERSION, 0, NULL, &str_info_size);\n        str_info = (char *)malloc(str_info_size);\n        clGetPlatformInfo(\n            platforms[i], CL_PLATFORM_VERSION, str_info_size, str_info, NULL);\n        cout << "  * " << str_info << endl;\n        free(str_info);\n\n        status = clGetDeviceIDs(\n            platforms[i], CL_DEVICE_TYPE_ALL, 0, NULL, &num_devices);\n        if(status != CL_SUCCESS) {\n            cerr << "Failed to get the number of devices in the platform "\n                 << i + 1 << \'.\' << endl;\n            continue;\n        }\n\n        if(num_devices > 0) {\n            cout << "  * The number of devices: " << num_devices << endl;\n        } else {\n            cerr << "Platform-" << i + 1 << " has no devices." << endl;\n            continue;\n        }\n\n        devices = (cl_device_id *)malloc(sizeof(cl_device_id) * num_devices);\n        clGetDeviceIDs(\n            platforms[i], CL_DEVICE_TYPE_ALL, num_devices, devices, NULL);\n\n        for(int j = 0; j < num_devices; ++j) {\n            cout << "    ================================================="\n                 << endl;\n            cout << "    Device-" << j + 1 << endl;\n\n            clGetDeviceInfo(\n                devices[j], CL_DEVICE_NAME, 0, NULL, &str_info_size);\n            str_info = (char *)malloc(str_info_size);\n            clGetDeviceInfo(\n                devices[j], CL_DEVICE_NAME, str_info_size, str_info, NULL);\n            cout << "    * name: " << str_info << endl;\n            free(str_info);\n\n            clGetDeviceInfo(devices[j],\n                            CL_DEVICE_MAX_COMPUTE_UNITS,\n                            sizeof(uint_info),\n                            &uint_info,\n                            NULL);\n            cout << "    * Max Compute Units: " << uint_info << endl;\n\n            clGetDeviceInfo(devices[j],\n                            CL_DEVICE_MAX_CLOCK_FREQUENCY,\n                            sizeof(uint_info),\n                            &uint_info,\n                            NULL);\n            cout << "    * Max Clock freq: " << uint_info << endl;\n\n            cout << "    ================================================="\n                 << endl;\n        }\n        cout << "  -----------------------------------------------" << endl;\n    }\n\n    free(devices);\n    free(platforms);\n    return 0;\n}\n'})}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-shell",children:"g++ -o get_info get_info.cpp -lOpenCL\n"})}),"\n",(0,c.jsx)(e.h2,{id:"saxpy-cpu-vs-gpu-or-mali-gpu",children:"SAXPY, CPU vs. GPU or Mali-GPU"}),"\n",(0,c.jsxs)(r.A,{defaultValue:"cpu-vs-gpu",values:[{label:"CPU vs. GPU",value:"cpu-vs-gpu"},{label:"CPU vs. Mali GPU",value:"cpu-vs-mali-gpu"}],children:[(0,c.jsxs)(a.A,{value:"cpu-vs-gpu",children:[(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-cpp",metastring:'title="saxpy_cpu_vs_gpu.cpp"',children:'#include <CL/cl.h>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n\nusing namespace std;\n\nconst int LENGTH = 1000000;\n\nconst char *source\n    = "__kernel void saxpy(const __global float *X, \\n"\n      "                    __global float *Y,       \\n"\n      "                    const float a) {         \\n"\n      "    uint gid = get_global_id(0);             \\n"\n      "    Y[gid]   = a * X[gid] + Y[gid];          \\n"\n      "}                                            \\n";\n\nint main(void) {\n    cout << fixed;\n\n    cl_int status;\n    time_t t, t2 = 0;\n\n    cl_uint         num_platforms = 1;\n    cl_platform_id *platforms\n        = (cl_platform_id *)malloc(sizeof(cl_platform_id) * num_platforms);\n    clGetPlatformIDs(num_platforms, platforms, NULL);\n\n    cl_uint       num_devices = 2;\n    cl_device_id *devices\n        = (cl_device_id *)malloc(sizeof(cl_device_id) * num_devices);\n    clGetDeviceIDs(\n        platforms[0], CL_DEVICE_TYPE_ALL, num_devices, devices, NULL);\n\n    cl_context context\n        = clCreateContext(NULL, 1, &devices[0], NULL, NULL, NULL);\n\n    cl_command_queue queue = clCreateCommandQueue(context, devices[0], 0, NULL);\n\n    cl_program program = clCreateProgramWithSource(\n        context, 1, (const char **)&source, NULL, NULL);\n\n    status = clBuildProgram(program, 1, &devices[0], NULL, NULL, NULL);\n    if(status != CL_SUCCESS) {\n        cerr << "clBuildProgram failed: " << status << endl;\n        char log[0x10000];\n        clGetProgramBuildInfo(\n            program, devices[0], CL_PROGRAM_BUILD_LOG, 0x10000, log, NULL);\n        cerr << log << endl;\n        return -1;\n    }\n\n    cl_kernel kernel = clCreateKernel(program, "saxpy", NULL);\n\n    cl_float *p_x      = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n    cl_float *p_y      = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n    cl_float *p_ret    = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n    cl_float *p_cl_ret = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n    cl_float  a        = 2.f;\n\n    srand(time(NULL));\n    for(int i = 0; i < LENGTH; ++i) {\n        p_x[i] = (cl_float)rand() / RAND_MAX;\n        p_y[i] = (cl_float)rand() / RAND_MAX;\n    }\n\n    cl_mem buf_x = clCreateBuffer(\n        context, CL_MEM_READ_ONLY, sizeof(cl_float) * LENGTH, NULL, NULL);\n    cl_mem buf_y = clCreateBuffer(\n        context, CL_MEM_READ_WRITE, sizeof(cl_float) * LENGTH, NULL, NULL);\n\n    t = clock();\n\n    for(int i = 0; i < LENGTH; ++i) { p_ret[i] = a * p_x[i] + p_y[i]; }\n\n    t = clock() - t;\n    cout << "CPU" << endl;\n    cout << "  * Time (s):                              "\n         << (double)t / CLOCKS_PER_SEC << endl;\n    cout << "---------------------------------------------------" << endl;\n\n    t = clock();\n\n    clEnqueueWriteBuffer(queue,\n                         buf_x,\n                         CL_TRUE,\n                         0,\n                         sizeof(cl_float) * LENGTH,\n                         p_x,\n                         0,\n                         NULL,\n                         NULL);\n    clEnqueueWriteBuffer(queue,\n                         buf_y,\n                         CL_TRUE,\n                         0,\n                         sizeof(cl_float) * LENGTH,\n                         p_y,\n                         0,\n                         NULL,\n                         NULL);\n\n    clSetKernelArg(kernel, 0, sizeof(cl_mem), &buf_x);\n    clSetKernelArg(kernel, 1, sizeof(cl_mem), &buf_y);\n    clSetKernelArg(kernel, 2, sizeof(cl_float), &a);\n\n    t = clock() - t;\n    t2 += t;\n    cout << "GPU" << endl;\n    cout << "  * Writes buffers and sets arguments (s): "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    t = clock();\n\n    clEnqueueNDRangeKernel(\n        queue, kernel, 1, NULL, (size_t *)&LENGTH, NULL, 0, NULL, NULL);\n\n    clFinish(queue);\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Runnig a kernel (s):                   "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    t = clock();\n\n    clEnqueueReadBuffer(queue,\n                        buf_y,\n                        CL_TRUE,\n                        0,\n                        sizeof(cl_float) * LENGTH,\n                        p_cl_ret,\n                        0,\n                        NULL,\n                        NULL);\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Reads buffer (s):                      "\n         << (double)t / CLOCKS_PER_SEC << endl;\n    cout << endl\n         << "  * Total time (s):                        "\n         << (double)t2 / CLOCKS_PER_SEC << endl;\n\n    for(int i = 0; i < LENGTH; ++i) {\n        if(abs(p_ret[i] - p_cl_ret[i]) > 0.01) {\n            cout << "Failed to SAXPY" << endl;\n        }\n    }\n\n    clReleaseMemObject(buf_y);\n    clReleaseMemObject(buf_x);\n    free(p_cl_ret);\n    free(p_ret);\n    free(p_y);\n    free(p_x);\n    clReleaseKernel(kernel);\n    clReleaseProgram(program);\n    clReleaseCommandQueue(queue);\n    clReleaseContext(context);\n    free(devices);\n    free(platforms);\n\n    return 0;\n}\n'})}),(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-shell",children:"g++ -o saxpy_cpu_vs_gpu saxpy_cpu_vs_gpu.cpp -lOpenCL\n"})})]}),(0,c.jsxs)(a.A,{value:"cpu-vs-mali-gpu",children:[(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-cpp",metastring:'title="saxpy_cpu_vs_mali.cpp"',children:'#include <CL/cl.h>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n\nusing namespace std;\n\nconst int LENGTH = 1000000;\n\nconst char *source\n    = "__kernel void saxpy(const __global float *X, \\n"\n      "                    __global float *Y,       \\n"\n      "                    const float a) {         \\n"\n      "    uint gid = get_global_id(0);             \\n"\n      "    Y[gid]   = a * X[gid] + Y[gid];          \\n"\n      "}                                            \\n";\n\nint main(void) {\n    cout << fixed;\n\n    cl_int status;\n    time_t t, t2 = 0;\n\n    cl_uint         num_platforms = 1;\n    cl_platform_id *platforms\n        = (cl_platform_id *)malloc(sizeof(cl_platform_id) * num_platforms);\n    clGetPlatformIDs(num_platforms, platforms, NULL);\n\n    cl_uint       num_devices = 2;\n    cl_device_id *devices\n        = (cl_device_id *)malloc(sizeof(cl_device_id) * num_devices);\n    clGetDeviceIDs(\n        platforms[0], CL_DEVICE_TYPE_ALL, num_devices, devices, NULL);\n\n    cl_context context\n        = clCreateContext(NULL, 1, &devices[0], NULL, NULL, NULL);\n\n    cl_command_queue queue = clCreateCommandQueueWithProperties(context, devices[0], 0, NULL);\n\n    cl_program program = clCreateProgramWithSource(\n        context, 1, (const char **)&source, NULL, NULL);\n\n    status = clBuildProgram(program, 1, &devices[0], NULL, NULL, NULL);\n    if(status != CL_SUCCESS) {\n        cerr << "clBuildProgram failed: " << status << endl;\n        char log[0x10000];\n        clGetProgramBuildInfo(\n            program, devices[0], CL_PROGRAM_BUILD_LOG, 0x10000, log, NULL);\n        cerr << log << endl;\n        return -1;\n    }\n\n    cl_kernel kernel = clCreateKernel(program, "saxpy", NULL);\n\n    cl_mem buf_x = clCreateBuffer(context,\n                                  CL_MEM_ALLOC_HOST_PTR | CL_MEM_READ_WRITE,\n                                  sizeof(cl_float) * LENGTH,\n                                  NULL,\n                                  NULL);\n    cl_mem buf_y = clCreateBuffer(context,\n                                  CL_MEM_ALLOC_HOST_PTR | CL_MEM_READ_WRITE,\n                                  sizeof(cl_float) * LENGTH,\n                                  NULL,\n                                  NULL);\n\n    cl_float *p_cl_x;\n    cl_float *p_cl_y;\n\n    cl_float *p_x;\n    cl_float *p_y;\n\n    cl_float *p_ret = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n\n    cl_float a = 2.f;\n\n    cout << "CPU" << endl;\n    t2 = 0;\n    t  = clock();\n\n    p_x = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n    p_y = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n\n    for(int i = 0; i < LENGTH; ++i) {\n        p_x[i] = (cl_float)i / LENGTH;\n        p_y[i] = (cl_float)i / LENGTH;\n    }\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Sets variables (s):                    "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    t = clock();\n\n    for(int i = 0; i < LENGTH; ++i) { p_ret[i] = a * p_x[i] + p_y[i]; }\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Runnig a forloop (s):                  "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    cout << endl\n         << "  * Total time (s):                        "\n         << (double)t2 / CLOCKS_PER_SEC << endl;\n    cout << "---------------------------------------------------" << endl;\n\n    free(p_x);\n    free(p_y);\n\n    cout << "GPU" << endl;\n    t2 = 0;\n    t  = clock();\n\n    p_cl_x = (cl_float *)clEnqueueMapBuffer(queue,\n                                            buf_x,\n                                            CL_TRUE,\n                                            CL_MAP_READ | CL_MAP_WRITE,\n                                            0,\n                                            sizeof(cl_float) * LENGTH,\n                                            0,\n                                            NULL,\n                                            NULL,\n                                            NULL);\n    p_cl_y = (cl_float *)clEnqueueMapBuffer(queue,\n                                            buf_y,\n                                            CL_TRUE,\n                                            CL_MAP_READ | CL_MAP_WRITE,\n                                            0,\n                                            sizeof(cl_float) * LENGTH,\n                                            0,\n                                            NULL,\n                                            NULL,\n                                            NULL);\n\n    for(int i = 0; i < LENGTH; ++i) {\n        p_cl_x[i] = (cl_float)i / LENGTH;\n        p_cl_y[i] = (cl_float)i / LENGTH;\n    }\n\n    clEnqueueUnmapMemObject(queue, buf_x, p_cl_x, 0, NULL, NULL);\n    clEnqueueUnmapMemObject(queue, buf_y, p_cl_y, 0, NULL, NULL);\n\n    clSetKernelArg(kernel, 0, sizeof(cl_mem), &buf_x);\n    clSetKernelArg(kernel, 1, sizeof(cl_mem), &buf_y);\n    clSetKernelArg(kernel, 2, sizeof(cl_float), &a);\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Mapping buffer and sets arguments (s): "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    t = clock();\n\n    clEnqueueNDRangeKernel(\n        queue, kernel, 1, NULL, (size_t *)&LENGTH, NULL, 0, NULL, NULL);\n    clFinish(queue);\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Runnig a kernel (s):                   "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    t = clock();\n\n    p_cl_y = (cl_float *)clEnqueueMapBuffer(queue,\n                                            buf_y,\n                                            CL_TRUE,\n                                            CL_MAP_READ | CL_MAP_WRITE,\n                                            0,\n                                            sizeof(cl_float) * LENGTH,\n                                            0,\n                                            NULL,\n                                            NULL,\n                                            NULL);\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Mapping buffer (s):                    "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    cout << endl\n         << "  * Total time (s):                        "\n         << (double)t2 / CLOCKS_PER_SEC << endl;\n\n    for(int i = 0; i < LENGTH; ++i) {\n        if(abs(p_ret[i] - p_cl_y[i]) > 0.01) {\n            cout << "Failed to SAXPY" << endl;\n            break;\n        }\n    }\n\n    clEnqueueUnmapMemObject(queue, buf_y, p_cl_x, 0, NULL, NULL);\n\n    clReleaseMemObject(buf_y);\n    clReleaseMemObject(buf_x);\n    free(p_ret);\n    clReleaseKernel(kernel);\n    clReleaseProgram(program);\n    clReleaseCommandQueue(queue);\n    clReleaseContext(context);\n    free(devices);\n    free(platforms);\n\n    return 0;\n}\n'})}),(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-shell",children:"g++ -o saxpy_cpu_vs_mali saxpy_cpu_vs_mali.cpp -lOpenCL\n"})})]})]})]})}function d(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(f,{...n})}):f(n)}}}]);