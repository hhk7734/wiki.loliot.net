"use strict";(self.webpackChunkwiki_loliot_net=self.webpackChunkwiki_loliot_net||[]).push([[66344],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var r=i(96540);const l={},t=r.createContext(l);function s(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),r.createElement(t.Provider,{value:n},e.children)}},45069:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"mcu/stm32/stm32-low-power-modes","title":"STM32 Low-power modes","description":"STM32 Low-power modes","source":"@site/docs/mcu/stm32/stm32-low-power-modes.mdx","sourceDirName":"mcu/stm32","slug":"/mcu/stm32/stm32-low-power-modes","permalink":"/docs/mcu/stm32/stm32-low-power-modes","draft":false,"unlisted":false,"editUrl":"https://github.com/hhk7734/wiki/tree/main/docs/mcu/stm32/stm32-low-power-modes.mdx","tags":[],"version":"current","lastUpdatedAt":1740588113000,"frontMatter":{"id":"stm32-low-power-modes","title":"STM32 Low-power modes","sidebar_label":"Low-power","description":"STM32 Low-power modes","keywords":["STM32","STM32CubeMX","STM32CubeIDE","Low-power"]},"sidebar":"stm32","previous":{"title":"SPI","permalink":"/docs/mcu/stm32/stm32-spi"}}');var l=i(74848),t=i(28453);const s={id:"stm32-low-power-modes",title:"STM32 Low-power modes",sidebar_label:"Low-power",description:"STM32 Low-power modes",keywords:["STM32","STM32CubeMX","STM32CubeIDE","Low-power"]},o=void 0,c={},a=[{value:"Overview",id:"overview",level:2},{value:"Power consumption range",id:"power-consumption-range",level:3},{value:"Modes",id:"modes",level:3},{value:"Standby with RTC Alarm",id:"standby-with-rtc-alarm",level:2},{value:"Pinout &amp; Configuration",id:"pinout--configuration",level:3},{value:"Clock Configuration",id:"clock-configuration",level:3},{value:"Example",id:"example",level:3}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,l.jsx)(n.p,{children:"HW: STM32L053"}),"\n",(0,l.jsx)(n.h3,{id:"power-consumption-range",children:"Power consumption range"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Range 1: VDD 1.71 ~ 3.6, CPU up to 32 MHz"}),"\n",(0,l.jsx)(n.li,{children:"Range 2: full VDD range, CPU up to 16 MHz"}),"\n",(0,l.jsx)(n.li,{children:"Range 3: full VDD range, CPU up to 4.2 MHz"}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"modes",children:"Modes"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Sleep"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Only the CPU is stopped."}),"\n",(0,l.jsx)(n.li,{children:"All peripherals continue to operate."}),"\n",(0,l.jsx)(n.li,{children:"All peripherals can wake up the CPU when an interrupt/event occurs."}),"\n",(0,l.jsx)(n.li,{children:"Power consumption at 16 MHz is about 1 mA with all peripherals off."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Low-power run"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["is achieved with","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"MSI RC oscillator set to the lowspeed clock (max 131 kHz),"}),"\n",(0,l.jsx)(n.li,{children:"execution from SRAM or Flash memory,"}),"\n",(0,l.jsx)(n.li,{children:"internal regulator in low-power mode."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Low-power sleep"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"is achieved by entering Sleep mode with the internal voltage regulator in low-power mode."}),"\n",(0,l.jsx)(n.li,{children:"All I/O pins keep the same state as in Run mode."}),"\n",(0,l.jsx)(n.li,{children:"When wakeup is triggered by an event or an interrupt, the system reverts to the Run mode with the regulator on."}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Stop mode"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"achieves the lowest power consumption while retaining the RAM and register contents and real time clock."}),"\n",(0,l.jsx)(n.li,{children:"All clocks in the Vcore domain are stopped."}),"\n",(0,l.jsx)(n.li,{children:"The PLL, MSI RC, HSE crystal and HSI RC oscillators are disabled."}),"\n",(0,l.jsx)(n.li,{children:"The LSE or LSI is still running."}),"\n",(0,l.jsx)(n.li,{children:"The voltage regulator is in the low-power mode."}),"\n",(0,l.jsx)(n.li,{children:"All I/O pins keep the same state as in Run mode."}),"\n",(0,l.jsx)(n.li,{children:"Some peripherals featuring wakeup capability can enable the HSI RC during Stop mode to detect their wakeup condition."}),"\n",(0,l.jsxs)(n.li,{children:["The device can be woken up from Stop mode by any of the EXTI line, in 3.5 \xb5s. It can be","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"any GPIO EXTI."}),"\n",(0,l.jsx)(n.li,{children:"the PVD output."}),"\n",(0,l.jsx)(n.li,{children:"the comparator 1 event or comparator 2 event (if internal reference voltage is on)"}),"\n",(0,l.jsx)(n.li,{children:"the USB/USART/I2C/LPUART/LPTIMER wakeup events."}),"\n",(0,l.jsxs)(n.li,{children:["the RTC alarm/tamper/timestamp/wakeup events ",(0,l.jsx)(n.strong,{children:"if with RTC"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.code,{children:"Standby mode"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["is used to achieve ",(0,l.jsx)(n.strong,{children:"the lowest power consumption"}),"."]}),"\n",(0,l.jsx)(n.li,{children:"The internal voltage regulator is switched off so that the entire Vcore domain is powered off."}),"\n",(0,l.jsx)(n.li,{children:"The PLL, MSI RC, HSE crystal and HSI RC oscillators are also switched off."}),"\n",(0,l.jsxs)(n.li,{children:["The LSE or LSI is still running ",(0,l.jsx)(n.strong,{children:"if with RTC"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:[(0,l.jsx)(n.strong,{children:"The RAM and register contents are lost"})," except for registers in the Standby circuitry (wakeup logic, IWDG, RTC, LSI, LSE Crystal 32 KHz oscillator, RCC_CSR register)"]}),"\n",(0,l.jsxs)(n.li,{children:["The device exits Standby mode in 60 \xb5s when","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"an external reset (NRST pin)"}),"\n",(0,l.jsx)(n.li,{children:"a rising edge on one of the three WKUP pins"}),"\n",(0,l.jsxs)(n.li,{children:["an IWDG reset ",(0,l.jsx)(n.strong,{children:"if with RTC"})]}),"\n",(0,l.jsxs)(n.li,{children:["RTC alarm (Alarm A or Alarm B), RTC tamper event, RTC timestamp event or RTC Wakeup event occurs, ",(0,l.jsx)(n.strong,{children:"if with RTC"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.admonition,{type:"danger",children:(0,l.jsxs)(n.p,{children:["The RTC, the IWDG, and the corresponding clock sources ",(0,l.jsx)(n.strong,{children:"are not stopped automatically"})," by entering Stop or Standby mode.The LCD is not stopped automatically by entering Stop mode."]})}),"\n",(0,l.jsx)(n.h2,{id:"standby-with-rtc-alarm",children:"Standby with RTC Alarm"}),"\n",(0,l.jsx)(n.h3,{id:"pinout--configuration",children:"Pinout & Configuration"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Timer","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["RTC","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Mode","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Activate Clock Source"}),"\n",(0,l.jsx)(n.li,{children:"Activate Calendar"}),"\n",(0,l.jsx)(n.li,{children:"Alarm A -> internal Alarm A"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["Configuration","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Parameter Settings","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"General -> Asynchronous Predivider value = 124"}),"\n",(0,l.jsx)(n.li,{children:"General -> Synchronous Predivider value = 295"}),"\n",(0,l.jsx)(n.li,{children:"37 KHz / (124 + 1) / (295 + 1) == 1 (Depend on clock source)"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(n.li,{children:["NVIC Settings","\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"RTC global interrupt -> Enable"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(n.h3,{id:"clock-configuration",children:"Clock Configuration"}),"\n",(0,l.jsx)(n.p,{children:"Set RTC clock."}),"\n",(0,l.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",metastring:'title="rtc.c"',children:"\n...\n\nvoid MX_RTC_Init(void)\n{\n    ...\n\n    /* USER CODE BEGIN Check_RTC_BKUP */\n    if(HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR0) == 0x1234) return;\n\n    ...\n\n    HAL_RTCEx_BKUPWrite(&hrtc,RTC_BKP_DR0,0x1234);\n    /* USER CODE END Check_RTC_BKUP */\n\n    ...\n}\n\n...\n\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-cpp",metastring:'title="main.c"',children:'\n...\n\n/* USER CODE BEGIN PV */\nRTC_TimeTypeDef sTime;\nRTC_DateTypeDef sDate;\nRTC_AlarmTypeDef sAlarm;\n/* USER CODE END PV */\n\n...\n\nint main(void) {\n\n    ...\n\n    /* USER CODE BEGIN 2 */\n    // Check the Standby flag\n    if(__HAL_PWR_GET_FLAG(PWR_FLAG_SB) != RESET) {\n        // Clear the Standby flag\n        __HAL_PWR_CLEAR_FLAG(PWR_FLAG_SB);\n        printf("Wake up from standby mode\\n");\n    } else {\n        printf("Power on or Reset\\n");\n    }\n\n    // Clear the Wake Up flag\n    __HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);\n\n    HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);\n    /* USER CODE END 2 */\n\n    ...\n\n        if(condition) {\n            HAL_RTC_GetTime(&hrtc, &sTime, RTC_FORMAT_BIN);    // BIN\n            // Must call HAL_RTC_GetDate() after HAL_RTC_GetTime()\n            HAL_RTC_GetDate(&hrtc, &sDate, RTC_FORMAT_BCD);    // BCD\n\n            // Set to compare only seconds\n            sAlarm.AlarmTime.Seconds        = (sTime.Seconds + 5) % 60;\n            sAlarm.AlarmTime.SubSeconds     = sTime.SubSeconds;\n            sAlarm.AlarmTime.SecondFraction = sTime.SecondFraction;\n            sAlarm.AlarmMask          = RTC_ALARMMASK_ALL & ~RTC_ALARMMASK_SECONDS;\n            sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_SS14_3;\n            sAlarm.Alarm              = RTC_ALARM_A;\n            HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN);\n\n            printf("Try to enter standby mode\\n");\n\n            HAL_PWR_EnterSTANDBYMode();\n            printf("Failed to enter Standby mode\\n");\n        }\n\n    ...\n}\n\n...\n\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(d,{...e})}):d(e)}}}]);