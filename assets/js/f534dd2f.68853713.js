"use strict";(self.webpackChunkwiki_loliot_net=self.webpackChunkwiki_loliot_net||[]).push([[79997],{86616:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>f,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"mcu/avr/avr-printf","title":"AVR Use printf() with UART","description":"AVR Use printf() with UART","source":"@site/docs/mcu/avr/avr-printf.mdx","sourceDirName":"mcu/avr","slug":"/mcu/avr/avr-printf","permalink":"/docs/mcu/avr/avr-printf","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1731420706000,"frontMatter":{"id":"avr-printf","title":"AVR Use printf() with UART","sidebar_label":"Use printf() with UART","description":"AVR Use printf() with UART","keywords":["AVR","UART","printf"]},"sidebar":"avr","previous":{"title":"Lock and Fuse bits","permalink":"/docs/mcu/avr/avr-lock-and-fuse-bits"},"next":{"title":"Internal EEPROM","permalink":"/docs/mcu/avr/avr-eeprom"}}');var r=t(74848),s=t(28453);const a={id:"avr-printf",title:"AVR Use printf() with UART",sidebar_label:"Use printf() with UART",description:"AVR Use printf() with UART",keywords:["AVR","UART","printf"]},c=void 0,o={},d=[{value:"struct FILE",id:"struct-file",level:2},{value:"Set stdout",id:"set-stdout",level:2}];function u(e){const n={code:"code",h2:"h2",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h2,{id:"struct-file",children:"struct FILE"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"struct __file {\n    char *        buf;   /* buffer pointer */\n    unsigned char unget; /* ungetc() buffer */\n    uint8_t       flags; /* flags, see below */\n#define __SRD     0x0001 /* OK to read */\n#define __SWR     0x0002 /* OK to write */\n#define __SSTR    0x0004 /* this is an sprintf/snprintf string */\n#define __SPGM    0x0008 /* fmt string is in progmem */\n#define __SERR    0x0010 /* found error */\n#define __SEOF    0x0020 /* found EOF */\n#define __SUNGET  0x040  /* ungetc() happened */\n#define __SMALLOC 0x80   /* handle is malloc()ed */\n#if 0\n/* possible future extensions, will require uint16_t flags */\n#define __SRW  0x0100 /* open for reading & writing */\n#define __SLBF 0x0200 /* line buffered */\n#define __SNBF 0x0400 /* unbuffered */\n#define __SMBF 0x0800 /* buf is from malloc */\n#endif\n    int size; /* size of buffer */\n    int len;  /* characters read or written so far */\n    int (*put)(char,\n               struct __file *); /* function to write one char to device */\n    int (*get)(struct __file *); /* function to read one char from device */\n    void *udata;                 /* User defined and accessible data. */\n};\n\ntypedef struct __file FILE;\n\n#define FDEV_SETUP_STREAM(p, g, f) \\\n    { .put = p, .get = g, .flags = f, .udata = 0, }\n"})}),"\n",(0,r.jsx)(n.h2,{id:"set-stdout",children:"Set stdout"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"#include \"uart0.h\"\n\n#include <avr/io.h>\n#include <stdio.h>\n\nstatic int uart_putchar(char c, FILE *stream) {\n    if(c == '\\n') { uart0_write('\\r'); }\n    uart0_write(c);\n    return 0;\n}\n\nstatic FILE _stdout = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);\n\nint main() {\n    uart0_init(115200);\n    stdout = &_stdout;\n\n    printf(\"Start setup.\\n\");\n\n    while(1) {\n\n    }\n}\n"})})]})}function f(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var i=t(96540);const r={},s=i.createContext(r);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);