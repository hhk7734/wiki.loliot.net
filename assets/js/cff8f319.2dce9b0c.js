"use strict";(self.webpackChunkwiki_loliot_net=self.webpackChunkwiki_loliot_net||[]).push([[34309],{78717:(n,e,l)=>{l.r(e),l.d(e,{assets:()=>u,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>s,toc:()=>_});var t=l(74848),c=l(28453),o=l(49489),r=l(7227);const a={id:"opencl-example",title:"OpenCL Example",sidebar_label:"Example",description:"OpenCL Example",keywords:["C++","OpenCL","Mali","SAXPY"]},i=void 0,s={id:"lang/cpp/libraries/opencl/opencl-example",title:"OpenCL Example",description:"OpenCL Example",source:"@site/docs/lang/cpp/libraries/opencl/opencl-example.mdx",sourceDirName:"lang/cpp/libraries/opencl",slug:"/lang/cpp/libraries/opencl/opencl-example",permalink:"/docs/lang/cpp/libraries/opencl/opencl-example",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedAt:1722869178e3,frontMatter:{id:"opencl-example",title:"OpenCL Example",sidebar_label:"Example",description:"OpenCL Example",keywords:["C++","OpenCL","Mali","SAXPY"]},sidebar:"cpp",previous:{title:"OpenCL with Mali GPU",permalink:"/docs/lang/cpp/libraries/opencl/opencl-with-mali-gpu"},next:{title:"Installation",permalink:"/docs/lang/cpp/libraries/opencv/opencv-installation"}},u={},_=[{value:"Platform informations",id:"platform-informations",level:2},{value:"SAXPY, CPU vs. GPU or Mali-GPU",id:"saxpy-cpu-vs-gpu-or-mali-gpu",level:2}];function f(n){const e={code:"code",h2:"h2",pre:"pre",...(0,c.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{id:"platform-informations",children:"Platform informations"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",metastring:'title="get_info.cpp"',children:'#include <CL/cl.h>\n#include <cstdlib>\n#include <iostream>\n\nusing namespace std;\n\nint main(void) {\n    cl_int  status;\n    size_t  str_info_size;\n    char *  str_info;\n    cl_uint uint_info;\n\n    cl_uint         num_platforms;\n    cl_platform_id *platforms;\n\n    cl_uint       num_devices;\n    cl_device_id *devices;\n\n    status = clGetPlatformIDs(0, NULL, &num_platforms);\n    if(status != CL_SUCCESS) {\n        cerr << "Failed to get the number of platforms." << endl;\n        return -1;\n    }\n\n    if(num_platforms > 0) {\n        cout << "* The number of platforms: " << num_platforms << endl;\n    } else {\n        cerr << "The number of platforms is zero." << endl;\n        return -1;\n    }\n\n    platforms\n        = (cl_platform_id *)malloc(sizeof(cl_platform_id) * num_platforms);\n    clGetPlatformIDs(num_platforms, platforms, NULL);\n\n    for(int i = 0; i < num_platforms; ++i) {\n        cout << "  -----------------------------------------------" << endl;\n        cout << "  Platform-" << i + 1 << endl;\n\n        clGetPlatformInfo(\n            platforms[i], CL_PLATFORM_NAME, 0, NULL, &str_info_size);\n        str_info = (char *)malloc(str_info_size);\n        clGetPlatformInfo(\n            platforms[i], CL_PLATFORM_NAME, str_info_size, str_info, NULL);\n        cout << "  * Platform: " << str_info << endl;\n        free(str_info);\n\n        clGetPlatformInfo(\n            platforms[i], CL_PLATFORM_PROFILE, 0, NULL, &str_info_size);\n        str_info = (char *)malloc(str_info_size);\n        clGetPlatformInfo(\n            platforms[i], CL_PLATFORM_PROFILE, str_info_size, str_info, NULL);\n        cout << "  * Profile: " << str_info << endl;\n        free(str_info);\n\n        clGetPlatformInfo(\n            platforms[i], CL_PLATFORM_VERSION, 0, NULL, &str_info_size);\n        str_info = (char *)malloc(str_info_size);\n        clGetPlatformInfo(\n            platforms[i], CL_PLATFORM_VERSION, str_info_size, str_info, NULL);\n        cout << "  * " << str_info << endl;\n        free(str_info);\n\n        status = clGetDeviceIDs(\n            platforms[i], CL_DEVICE_TYPE_ALL, 0, NULL, &num_devices);\n        if(status != CL_SUCCESS) {\n            cerr << "Failed to get the number of devices in the platform "\n                 << i + 1 << \'.\' << endl;\n            continue;\n        }\n\n        if(num_devices > 0) {\n            cout << "  * The number of devices: " << num_devices << endl;\n        } else {\n            cerr << "Platform-" << i + 1 << " has no devices." << endl;\n            continue;\n        }\n\n        devices = (cl_device_id *)malloc(sizeof(cl_device_id) * num_devices);\n        clGetDeviceIDs(\n            platforms[i], CL_DEVICE_TYPE_ALL, num_devices, devices, NULL);\n\n        for(int j = 0; j < num_devices; ++j) {\n            cout << "    ================================================="\n                 << endl;\n            cout << "    Device-" << j + 1 << endl;\n\n            clGetDeviceInfo(\n                devices[j], CL_DEVICE_NAME, 0, NULL, &str_info_size);\n            str_info = (char *)malloc(str_info_size);\n            clGetDeviceInfo(\n                devices[j], CL_DEVICE_NAME, str_info_size, str_info, NULL);\n            cout << "    * name: " << str_info << endl;\n            free(str_info);\n\n            clGetDeviceInfo(devices[j],\n                            CL_DEVICE_MAX_COMPUTE_UNITS,\n                            sizeof(uint_info),\n                            &uint_info,\n                            NULL);\n            cout << "    * Max Compute Units: " << uint_info << endl;\n\n            clGetDeviceInfo(devices[j],\n                            CL_DEVICE_MAX_CLOCK_FREQUENCY,\n                            sizeof(uint_info),\n                            &uint_info,\n                            NULL);\n            cout << "    * Max Clock freq: " << uint_info << endl;\n\n            cout << "    ================================================="\n                 << endl;\n        }\n        cout << "  -----------------------------------------------" << endl;\n    }\n\n    free(devices);\n    free(platforms);\n    return 0;\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-shell",children:"g++ -o get_info get_info.cpp -lOpenCL\n"})}),"\n",(0,t.jsx)(e.h2,{id:"saxpy-cpu-vs-gpu-or-mali-gpu",children:"SAXPY, CPU vs. GPU or Mali-GPU"}),"\n",(0,t.jsxs)(o.A,{defaultValue:"cpu-vs-gpu",values:[{label:"CPU vs. GPU",value:"cpu-vs-gpu"},{label:"CPU vs. Mali GPU",value:"cpu-vs-mali-gpu"}],children:[(0,t.jsxs)(r.A,{value:"cpu-vs-gpu",children:[(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",metastring:'title="saxpy_cpu_vs_gpu.cpp"',children:'#include <CL/cl.h>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n\nusing namespace std;\n\nconst int LENGTH = 1000000;\n\nconst char *source\n    = "__kernel void saxpy(const __global float *X, \\n"\n      "                    __global float *Y,       \\n"\n      "                    const float a) {         \\n"\n      "    uint gid = get_global_id(0);             \\n"\n      "    Y[gid]   = a * X[gid] + Y[gid];          \\n"\n      "}                                            \\n";\n\nint main(void) {\n    cout << fixed;\n\n    cl_int status;\n    time_t t, t2 = 0;\n\n    cl_uint         num_platforms = 1;\n    cl_platform_id *platforms\n        = (cl_platform_id *)malloc(sizeof(cl_platform_id) * num_platforms);\n    clGetPlatformIDs(num_platforms, platforms, NULL);\n\n    cl_uint       num_devices = 2;\n    cl_device_id *devices\n        = (cl_device_id *)malloc(sizeof(cl_device_id) * num_devices);\n    clGetDeviceIDs(\n        platforms[0], CL_DEVICE_TYPE_ALL, num_devices, devices, NULL);\n\n    cl_context context\n        = clCreateContext(NULL, 1, &devices[0], NULL, NULL, NULL);\n\n    cl_command_queue queue = clCreateCommandQueue(context, devices[0], 0, NULL);\n\n    cl_program program = clCreateProgramWithSource(\n        context, 1, (const char **)&source, NULL, NULL);\n\n    status = clBuildProgram(program, 1, &devices[0], NULL, NULL, NULL);\n    if(status != CL_SUCCESS) {\n        cerr << "clBuildProgram failed: " << status << endl;\n        char log[0x10000];\n        clGetProgramBuildInfo(\n            program, devices[0], CL_PROGRAM_BUILD_LOG, 0x10000, log, NULL);\n        cerr << log << endl;\n        return -1;\n    }\n\n    cl_kernel kernel = clCreateKernel(program, "saxpy", NULL);\n\n    cl_float *p_x      = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n    cl_float *p_y      = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n    cl_float *p_ret    = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n    cl_float *p_cl_ret = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n    cl_float  a        = 2.f;\n\n    srand(time(NULL));\n    for(int i = 0; i < LENGTH; ++i) {\n        p_x[i] = (cl_float)rand() / RAND_MAX;\n        p_y[i] = (cl_float)rand() / RAND_MAX;\n    }\n\n    cl_mem buf_x = clCreateBuffer(\n        context, CL_MEM_READ_ONLY, sizeof(cl_float) * LENGTH, NULL, NULL);\n    cl_mem buf_y = clCreateBuffer(\n        context, CL_MEM_READ_WRITE, sizeof(cl_float) * LENGTH, NULL, NULL);\n\n    t = clock();\n\n    for(int i = 0; i < LENGTH; ++i) { p_ret[i] = a * p_x[i] + p_y[i]; }\n\n    t = clock() - t;\n    cout << "CPU" << endl;\n    cout << "  * Time (s):                              "\n         << (double)t / CLOCKS_PER_SEC << endl;\n    cout << "---------------------------------------------------" << endl;\n\n    t = clock();\n\n    clEnqueueWriteBuffer(queue,\n                         buf_x,\n                         CL_TRUE,\n                         0,\n                         sizeof(cl_float) * LENGTH,\n                         p_x,\n                         0,\n                         NULL,\n                         NULL);\n    clEnqueueWriteBuffer(queue,\n                         buf_y,\n                         CL_TRUE,\n                         0,\n                         sizeof(cl_float) * LENGTH,\n                         p_y,\n                         0,\n                         NULL,\n                         NULL);\n\n    clSetKernelArg(kernel, 0, sizeof(cl_mem), &buf_x);\n    clSetKernelArg(kernel, 1, sizeof(cl_mem), &buf_y);\n    clSetKernelArg(kernel, 2, sizeof(cl_float), &a);\n\n    t = clock() - t;\n    t2 += t;\n    cout << "GPU" << endl;\n    cout << "  * Writes buffers and sets arguments (s): "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    t = clock();\n\n    clEnqueueNDRangeKernel(\n        queue, kernel, 1, NULL, (size_t *)&LENGTH, NULL, 0, NULL, NULL);\n\n    clFinish(queue);\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Runnig a kernel (s):                   "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    t = clock();\n\n    clEnqueueReadBuffer(queue,\n                        buf_y,\n                        CL_TRUE,\n                        0,\n                        sizeof(cl_float) * LENGTH,\n                        p_cl_ret,\n                        0,\n                        NULL,\n                        NULL);\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Reads buffer (s):                      "\n         << (double)t / CLOCKS_PER_SEC << endl;\n    cout << endl\n         << "  * Total time (s):                        "\n         << (double)t2 / CLOCKS_PER_SEC << endl;\n\n    for(int i = 0; i < LENGTH; ++i) {\n        if(abs(p_ret[i] - p_cl_ret[i]) > 0.01) {\n            cout << "Failed to SAXPY" << endl;\n        }\n    }\n\n    clReleaseMemObject(buf_y);\n    clReleaseMemObject(buf_x);\n    free(p_cl_ret);\n    free(p_ret);\n    free(p_y);\n    free(p_x);\n    clReleaseKernel(kernel);\n    clReleaseProgram(program);\n    clReleaseCommandQueue(queue);\n    clReleaseContext(context);\n    free(devices);\n    free(platforms);\n\n    return 0;\n}\n'})}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-shell",children:"g++ -o saxpy_cpu_vs_gpu saxpy_cpu_vs_gpu.cpp -lOpenCL\n"})})]}),(0,t.jsxs)(r.A,{value:"cpu-vs-mali-gpu",children:[(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-cpp",metastring:'title="saxpy_cpu_vs_mali.cpp"',children:'#include <CL/cl.h>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n\nusing namespace std;\n\nconst int LENGTH = 1000000;\n\nconst char *source\n    = "__kernel void saxpy(const __global float *X, \\n"\n      "                    __global float *Y,       \\n"\n      "                    const float a) {         \\n"\n      "    uint gid = get_global_id(0);             \\n"\n      "    Y[gid]   = a * X[gid] + Y[gid];          \\n"\n      "}                                            \\n";\n\nint main(void) {\n    cout << fixed;\n\n    cl_int status;\n    time_t t, t2 = 0;\n\n    cl_uint         num_platforms = 1;\n    cl_platform_id *platforms\n        = (cl_platform_id *)malloc(sizeof(cl_platform_id) * num_platforms);\n    clGetPlatformIDs(num_platforms, platforms, NULL);\n\n    cl_uint       num_devices = 2;\n    cl_device_id *devices\n        = (cl_device_id *)malloc(sizeof(cl_device_id) * num_devices);\n    clGetDeviceIDs(\n        platforms[0], CL_DEVICE_TYPE_ALL, num_devices, devices, NULL);\n\n    cl_context context\n        = clCreateContext(NULL, 1, &devices[0], NULL, NULL, NULL);\n\n    cl_command_queue queue = clCreateCommandQueueWithProperties(context, devices[0], 0, NULL);\n\n    cl_program program = clCreateProgramWithSource(\n        context, 1, (const char **)&source, NULL, NULL);\n\n    status = clBuildProgram(program, 1, &devices[0], NULL, NULL, NULL);\n    if(status != CL_SUCCESS) {\n        cerr << "clBuildProgram failed: " << status << endl;\n        char log[0x10000];\n        clGetProgramBuildInfo(\n            program, devices[0], CL_PROGRAM_BUILD_LOG, 0x10000, log, NULL);\n        cerr << log << endl;\n        return -1;\n    }\n\n    cl_kernel kernel = clCreateKernel(program, "saxpy", NULL);\n\n    cl_mem buf_x = clCreateBuffer(context,\n                                  CL_MEM_ALLOC_HOST_PTR | CL_MEM_READ_WRITE,\n                                  sizeof(cl_float) * LENGTH,\n                                  NULL,\n                                  NULL);\n    cl_mem buf_y = clCreateBuffer(context,\n                                  CL_MEM_ALLOC_HOST_PTR | CL_MEM_READ_WRITE,\n                                  sizeof(cl_float) * LENGTH,\n                                  NULL,\n                                  NULL);\n\n    cl_float *p_cl_x;\n    cl_float *p_cl_y;\n\n    cl_float *p_x;\n    cl_float *p_y;\n\n    cl_float *p_ret = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n\n    cl_float a = 2.f;\n\n    cout << "CPU" << endl;\n    t2 = 0;\n    t  = clock();\n\n    p_x = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n    p_y = (cl_float *)calloc(LENGTH, sizeof(cl_float));\n\n    for(int i = 0; i < LENGTH; ++i) {\n        p_x[i] = (cl_float)i / LENGTH;\n        p_y[i] = (cl_float)i / LENGTH;\n    }\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Sets variables (s):                    "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    t = clock();\n\n    for(int i = 0; i < LENGTH; ++i) { p_ret[i] = a * p_x[i] + p_y[i]; }\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Runnig a forloop (s):                  "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    cout << endl\n         << "  * Total time (s):                        "\n         << (double)t2 / CLOCKS_PER_SEC << endl;\n    cout << "---------------------------------------------------" << endl;\n\n    free(p_x);\n    free(p_y);\n\n    cout << "GPU" << endl;\n    t2 = 0;\n    t  = clock();\n\n    p_cl_x = (cl_float *)clEnqueueMapBuffer(queue,\n                                            buf_x,\n                                            CL_TRUE,\n                                            CL_MAP_READ | CL_MAP_WRITE,\n                                            0,\n                                            sizeof(cl_float) * LENGTH,\n                                            0,\n                                            NULL,\n                                            NULL,\n                                            NULL);\n    p_cl_y = (cl_float *)clEnqueueMapBuffer(queue,\n                                            buf_y,\n                                            CL_TRUE,\n                                            CL_MAP_READ | CL_MAP_WRITE,\n                                            0,\n                                            sizeof(cl_float) * LENGTH,\n                                            0,\n                                            NULL,\n                                            NULL,\n                                            NULL);\n\n    for(int i = 0; i < LENGTH; ++i) {\n        p_cl_x[i] = (cl_float)i / LENGTH;\n        p_cl_y[i] = (cl_float)i / LENGTH;\n    }\n\n    clEnqueueUnmapMemObject(queue, buf_x, p_cl_x, 0, NULL, NULL);\n    clEnqueueUnmapMemObject(queue, buf_y, p_cl_y, 0, NULL, NULL);\n\n    clSetKernelArg(kernel, 0, sizeof(cl_mem), &buf_x);\n    clSetKernelArg(kernel, 1, sizeof(cl_mem), &buf_y);\n    clSetKernelArg(kernel, 2, sizeof(cl_float), &a);\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Mapping buffer and sets arguments (s): "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    t = clock();\n\n    clEnqueueNDRangeKernel(\n        queue, kernel, 1, NULL, (size_t *)&LENGTH, NULL, 0, NULL, NULL);\n    clFinish(queue);\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Runnig a kernel (s):                   "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    t = clock();\n\n    p_cl_y = (cl_float *)clEnqueueMapBuffer(queue,\n                                            buf_y,\n                                            CL_TRUE,\n                                            CL_MAP_READ | CL_MAP_WRITE,\n                                            0,\n                                            sizeof(cl_float) * LENGTH,\n                                            0,\n                                            NULL,\n                                            NULL,\n                                            NULL);\n\n    t = clock() - t;\n    t2 += t;\n    cout << "  * Mapping buffer (s):                    "\n         << (double)t / CLOCKS_PER_SEC << endl;\n\n    cout << endl\n         << "  * Total time (s):                        "\n         << (double)t2 / CLOCKS_PER_SEC << endl;\n\n    for(int i = 0; i < LENGTH; ++i) {\n        if(abs(p_ret[i] - p_cl_y[i]) > 0.01) {\n            cout << "Failed to SAXPY" << endl;\n            break;\n        }\n    }\n\n    clEnqueueUnmapMemObject(queue, buf_y, p_cl_x, 0, NULL, NULL);\n\n    clReleaseMemObject(buf_y);\n    clReleaseMemObject(buf_x);\n    free(p_ret);\n    clReleaseKernel(kernel);\n    clReleaseProgram(program);\n    clReleaseCommandQueue(queue);\n    clReleaseContext(context);\n    free(devices);\n    free(platforms);\n\n    return 0;\n}\n'})}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-shell",children:"g++ -o saxpy_cpu_vs_mali saxpy_cpu_vs_mali.cpp -lOpenCL\n"})})]})]})]})}function d(n={}){const{wrapper:e}={...(0,c.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(f,{...n})}):f(n)}},7227:(n,e,l)=>{l.d(e,{A:()=>r});l(96540);var t=l(34164);const c={tabItem:"tabItem_Ymn6"};var o=l(74848);function r(n){let{children:e,hidden:l,className:r}=n;return(0,o.jsx)("div",{role:"tabpanel",className:(0,t.A)(c.tabItem,r),hidden:l,children:e})}},49489:(n,e,l)=>{l.d(e,{A:()=>g});var t=l(96540),c=l(34164),o=l(24245),r=l(56347),a=l(36494),i=l(62814),s=l(67548),u=l(69900);function _(n){var e,l;return null!=(e=null==(l=t.Children.toArray(n).filter((n=>"\n"!==n)).map((n=>{if(!n||(0,t.isValidElement)(n)&&function(n){const{props:e}=n;return!!e&&"object"==typeof e&&"value"in e}(n))return n;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof n.type?n.type:n.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:l.filter(Boolean))?e:[]}function f(n){const{values:e,children:l}=n;return(0,t.useMemo)((()=>{const n=null!=e?e:function(n){return _(n).map((n=>{let{props:{value:e,label:l,attributes:t,default:c}}=n;return{value:e,label:l,attributes:t,default:c}}))}(l);return function(n){const e=(0,s.X)(n,((n,e)=>n.value===e.value));if(e.length>0)throw new Error('Docusaurus error: Duplicate values "'+e.map((n=>n.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(n),n}),[e,l])}function d(n){let{value:e,tabValues:l}=n;return l.some((n=>n.value===e))}function p(n){let{queryString:e=!1,groupId:l}=n;const c=(0,r.W6)(),o=function(n){let{queryString:e=!1,groupId:l}=n;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!l)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=l?l:null}({queryString:e,groupId:l});return[(0,i.aZ)(o),(0,t.useCallback)((n=>{if(!o)return;const e=new URLSearchParams(c.location.search);e.set(o,n),c.replace({...c.location,search:e.toString()})}),[o,c])]}function L(n){const{defaultValue:e,queryString:l=!1,groupId:c}=n,o=f(n),[r,i]=(0,t.useState)((()=>function(n){var e;let{defaultValue:l,tabValues:t}=n;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(l){if(!d({value:l,tabValues:t}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+l+'" but none of its children has the corresponding value. Available values are: '+t.map((n=>n.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return l}const c=null!=(e=t.find((n=>n.default)))?e:t[0];if(!c)throw new Error("Unexpected error: 0 tabValues");return c.value}({defaultValue:e,tabValues:o}))),[s,_]=p({queryString:l,groupId:c}),[L,m]=function(n){let{groupId:e}=n;const l=function(n){return n?"docusaurus.tab."+n:null}(e),[c,o]=(0,u.Dv)(l);return[c,(0,t.useCallback)((n=>{l&&o.set(n)}),[l,o])]}({groupId:c}),C=(()=>{const n=null!=s?s:L;return d({value:n,tabValues:o})?n:null})();(0,a.A)((()=>{C&&i(C)}),[C]);return{selectedValue:r,selectValue:(0,t.useCallback)((n=>{if(!d({value:n,tabValues:o}))throw new Error("Can't select invalid tab value="+n);i(n),_(n),m(n)}),[_,m,o]),tabValues:o}}var m=l(11062);const C={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var E=l(74848);function v(n){let{className:e,block:l,selectedValue:t,selectValue:r,tabValues:a}=n;const i=[],{blockElementScrollPositionUntilNextRender:s}=(0,o.a_)(),u=n=>{const e=n.currentTarget,l=i.indexOf(e),c=a[l].value;c!==t&&(s(e),r(c))},_=n=>{var e;let l=null;switch(n.key){case"Enter":u(n);break;case"ArrowRight":{var t;const e=i.indexOf(n.currentTarget)+1;l=null!=(t=i[e])?t:i[0];break}case"ArrowLeft":{var c;const e=i.indexOf(n.currentTarget)-1;l=null!=(c=i[e])?c:i[i.length-1];break}}null==(e=l)||e.focus()};return(0,E.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.A)("tabs",{"tabs--block":l},e),children:a.map((n=>{let{value:e,label:l,attributes:o}=n;return(0,E.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:n=>i.push(n),onKeyDown:_,onClick:u,...o,className:(0,c.A)("tabs__item",C.tabItem,null==o?void 0:o.className,{"tabs__item--active":t===e}),children:null!=l?l:e},e)}))})}function N(n){let{lazy:e,children:l,selectedValue:c}=n;const o=(Array.isArray(l)?l:[l]).filter(Boolean);if(e){const n=o.find((n=>n.props.value===c));return n?(0,t.cloneElement)(n,{className:"margin-top--md"}):null}return(0,E.jsx)("div",{className:"margin-top--md",children:o.map(((n,e)=>(0,t.cloneElement)(n,{key:e,hidden:n.props.value!==c})))})}function b(n){const e=L(n);return(0,E.jsxs)("div",{className:(0,c.A)("tabs-container",C.tabList),children:[(0,E.jsx)(v,{...e,...n}),(0,E.jsx)(N,{...e,...n})]})}function g(n){const e=(0,m.A)();return(0,E.jsx)(b,{...n,children:_(n.children)},String(e))}},28453:(n,e,l)=>{l.d(e,{R:()=>r,x:()=>a});var t=l(96540);const c={},o=t.createContext(c);function r(n){const e=t.useContext(o);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(c):n.components||c:r(n.components),t.createElement(o.Provider,{value:e},n.children)}}}]);