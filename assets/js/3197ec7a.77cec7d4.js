"use strict";(self.webpackChunkwiki_loliot_net=self.webpackChunkwiki_loliot_net||[]).push([[98227],{28453:(n,e,i)=>{i.d(e,{R:()=>s,x:()=>o});var t=i(96540);const c={},r=t.createContext(c);function s(n){const e=t.useContext(r);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(c):n.components||c:s(n.components),t.createElement(r.Provider,{value:e},n.children)}},56187:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>o,default:()=>f,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"mcu/infineon/tricore-tc27d-asc","title":"TriCore TC27D ASC(UART)","description":"TriCore TC27D ASC(UART)","source":"@site/docs/mcu/infineon/tricore-tc27d-asc.mdx","sourceDirName":"mcu/infineon","slug":"/mcu/infineon/tricore-tc27d-asc","permalink":"/docs/mcu/infineon/tricore-tc27d-asc","draft":false,"unlisted":false,"editUrl":"https://github.com/hhk7734/wiki/tree/main/docs/mcu/infineon/tricore-tc27d-asc.mdx","tags":[],"version":"current","lastUpdatedAt":1741888030000,"frontMatter":{"id":"tricore-tc27d-asc","title":"TriCore TC27D ASC(UART)","sidebar_label":"TC27D ASC(UART)","description":"TriCore TC27D ASC(UART)","keywords":["Infineon","TriCore","TC275","ASC"]},"sidebar":"infineon","previous":{"title":"TC27D BSP(Time, GPIO)","permalink":"/docs/mcu/infineon/tricore-tc27d-bsp"},"next":{"title":"TC27D terminal","permalink":"/docs/mcu/infineon/tricore-tc27d-terminal"}}');var c=i(74848),r=i(28453);const s={id:"tricore-tc27d-asc",title:"TriCore TC27D ASC(UART)",sidebar_label:"TC27D ASC(UART)",description:"TriCore TC27D ASC(UART)",keywords:["Infineon","TriCore","TC275","ASC"]},o=void 0,a={},d=[{value:"Related header",id:"related-header",level:2},{value:"IfxAsclin_Asc.h",id:"ifxasclin_asch",level:2},{value:"Examples",id:"examples",level:2},{value:"Read/Write",id:"readwrite",level:3}];function l(n){const e={admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...n.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(e.p,{children:"HW: ShieldBuddy TC275"}),"\n",(0,c.jsx)(e.admonition,{type:"info",children:(0,c.jsx)(e.p,{children:"BaseFramework\uc5d0\ub294 Bsp\uac00 \uae30\ubcf8 \ub77c\uc774\ube0c\ub7ec\ub9ac\ub85c \uc81c\uacf5\ub418\uc9c0 \uc54a\uc2b5\ub2c8\ub2e4. BaseFramework\ub97c \ud504\ub85c\uc81d\ud2b8 \uc2dc\uc791\uc73c\ub85c \uc0ac\uc6a9\ud558\ub294 \uacbd\uc6b0 iLLD\ub97c \ub2e4\uc6b4\ub85c\ub4dc \ubc1b\uc544 BaseSw\ub97c \uad50\uccb4\ud574\uc8fc\uc2dc\uac70\ub098 \ud544\uc694\ud55c \ub77c\uc774\ube0c\ub7ec\ub9ac\ub9cc \ucd94\uac00\ud574\uc8fc\uc2dc\uae30 \ubc14\ub78d\ub2c8\ub2e4."})}),"\n",(0,c.jsx)(e.h2,{id:"related-header",children:"Related header"}),"\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"IfxAsclin_cfg.h"}),": ASCLIN on-chip implementation data."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"IfxAsclin_PinMap.h"}),": ASCLIN I/O map."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"IfxAsclin_Asc.h"}),": ASCLIN ASC details."]}),"\n",(0,c.jsxs)(e.li,{children:[(0,c.jsx)(e.code,{children:"IfxAsclin.h"}),": ASCLIN basic functionality."]}),"\n"]}),"\n",(0,c.jsx)(e.h2,{id:"ifxasclin_asch",children:"IfxAsclin_Asc.h"}),"\n",(0,c.jsxs)(e.blockquote,{children:["\n",(0,c.jsxs)(e.ul,{children:["\n",(0,c.jsx)(e.li,{children:"The ASC interface driver provides a default ASCLIN configuration for asynchronous serial communication in 8bit mode, and a set of data transfer routines."}),"\n",(0,c.jsx)(e.li,{children:"Data transfers are buffered by the hardware based FIFOs, and in addition by software based FIFOs with a configurable size. Incoming and outgoing data is transfered in background from/to the ASCLIN peripheral by interrupt service handlers, which are part of this driver as well. This allows a nonblocking communication without stalling the thread(s) from where data is sent and received."}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(e.h2,{id:"examples",children:"Examples"}),"\n",(0,c.jsx)(e.admonition,{type:"info",children:(0,c.jsx)(e.p,{children:"\ud3f4\ub354\ub97c \uc0c8\ub85c \uc0dd\uc131\ud55c \uacbd\uc6b0 clean projet \ud6c4, \ub2e4\uc2dc \ube4c\ub4dc\ud574\uc57c \ud569\ub2c8\ub2e4."})}),"\n",(0,c.jsxs)(e.p,{children:[(0,c.jsx)(e.code,{children:"0_Src/AppSw/Tricore/TC27D_lib/Config/Ifx_IntPrioDef.h"}),"\ub97c \ub9cc\ub4e4\uace0 \uc544\ub798\uc640 \uac19\uc774 \uc791\uc131\ud569\ub2c8\ub2e4."]}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-c",children:"#pragma once\n\n#define IFX_INTPRIO_ASCLIN3_TX 1\n#define IFX_INTPRIO_ASCLIN3_RX 2\n#define IFX_INTPRIO_ASCLIN3_ER 3\n"})}),"\n",(0,c.jsx)(e.h3,{id:"readwrite",children:"Read/Write"}),"\n",(0,c.jsx)(e.pre,{children:(0,c.jsx)(e.code,{className:"language-c",children:'#include "IfxAsclin_Asc.h"\n#include "IfxAsclin_PinMap.h"\n#include "IfxCpu.h"\n#include "IfxCpu_Irq.h"\n#include "IfxScuWdt.h"\n#include "Ifx_IntPrioDef.h"\n#include "Ifx_Types.h"\n\nIfxCpu_syncEvent cpuSyncEvent = 0;\n\nIfxAsclin_Asc asc;\n#define ASC_TX_BUFFER_SIZE 64\nstatic uint8 ascTxBuffer[ASC_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];\n#define ASC_RX_BUFFER_SIZE 64\nstatic uint8 ascRxBuffer[ASC_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];\n\nIFX_INTERRUPT(asclin3TxISR, 0, IFX_INTPRIO_ASCLIN3_TX) {\n    IfxAsclin_Asc_isrTransmit(&asc);\n}\nIFX_INTERRUPT(asclin3RxISR, 0, IFX_INTPRIO_ASCLIN3_RX) {\n    IfxAsclin_Asc_isrReceive(&asc);\n}\nIFX_INTERRUPT(asclin3ErISR, 0, IFX_INTPRIO_ASCLIN3_ER) {\n    IfxAsclin_Asc_isrError(&asc);\n}\n\nvoid ASC3_init(uint32 baudrate) {\n    // create module config\n    IfxAsclin_Asc_Config ascConfig;\n\n    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN3);\n\n    // set the desired baudrate\n    ascConfig.baudrate.prescaler = 1;\n    ascConfig.baudrate.baudrate\n        = baudrate;    // FDR values will be calculated in initModule\n    // ISR priorities and interrupt target\n    ascConfig.interrupt.txPriority = IFX_INTPRIO_ASCLIN3_TX;\n    ascConfig.interrupt.rxPriority = IFX_INTPRIO_ASCLIN3_RX;\n    ascConfig.interrupt.erPriority = IFX_INTPRIO_ASCLIN3_ER;\n    ascConfig.interrupt.typeOfService\n        = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());\n    // FIFO configuration\n    ascConfig.txBuffer     = &ascTxBuffer;\n    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;\n    ascConfig.rxBuffer     = &ascRxBuffer;\n    ascConfig.rxBufferSize = ASC_RX_BUFFER_SIZE;\n    // pin configuration\n    const IfxAsclin_Asc_Pins pins\n        = {NULL,\n           IfxPort_InputMode_pullUp,    // CTS pin not used\n           &IfxAsclin3_RXD_P32_2_IN,\n           IfxPort_InputMode_pullUp,    // Rx pin\n           NULL,\n           IfxPort_OutputMode_pushPull,    // RTS pin not used\n           &IfxAsclin3_TX_P15_7_OUT,\n           IfxPort_OutputMode_pushPull,    // Tx pin\n           IfxPort_PadDriver_cmosAutomotiveSpeed1};\n    ascConfig.pins = &pins;\n    IfxAsclin_Asc_initModule(&asc, &ascConfig);\n}\n\nint core0_main(void) {\n    IfxCpu_enableInterrupts();\n    /*\n     * !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!\n     * Enable the watchdog in the demo if it is required and also service the\n     * watchdog periodically\n     * */\n    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());\n    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());\n\n    /* Cpu sync event wait*/\n    IfxCpu_emitEvent(&cpuSyncEvent);\n    IfxCpu_waitEvent(&cpuSyncEvent, 1);\n\n    ASC3_init(115200);\n\n    char *    hello = "Hello\\r\\n";\n    Ifx_SizeT count = 7;\n\n    IfxAsclin_Asc_write(&asc, hello, &count, TIME_INFINITE);\n\n    while(1) {\n        if(IfxAsclin_Asc_getReadCount(&asc)) {\n            IfxAsclin_Asc_blockingWrite(&asc, IfxAsclin_Asc_blockingRead(&asc));\n        }\n    }\n\n    return 1;\n}\n'})})]})}function f(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,c.jsx)(e,{...n,children:(0,c.jsx)(l,{...n})}):l(n)}}}]);