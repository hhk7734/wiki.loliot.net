"use strict";(self.webpackChunkwiki_loliot_net=self.webpackChunkwiki_loliot_net||[]).push([[32363],{13591:(_,n,A)=>{A.r(n),A.d(n,{assets:()=>C,contentTitle:()=>a,default:()=>r,frontMatter:()=>i,metadata:()=>e,toc:()=>s});const e=JSON.parse('{"id":"mcu/sam/sam-sam4s2a-adc","title":"SAM4S2A ADC","description":"SAM4S2A ADC","source":"@site/docs/mcu/sam/sam-sam4s2a-adc.mdx","sourceDirName":"mcu/sam","slug":"/mcu/sam/sam-sam4s2a-adc","permalink":"/docs/mcu/sam/sam-sam4s2a-adc","draft":false,"unlisted":false,"editUrl":"https://github.com/hhk7734/wiki/tree/main/docs/mcu/sam/sam-sam4s2a-adc.mdx","tags":[],"version":"current","lastUpdatedAt":1746291681000,"frontMatter":{"id":"sam-sam4s2a-adc","title":"SAM4S2A ADC","sidebar_label":"ADC","description":"SAM4S2A ADC","keywords":["SAM","ADC"]},"sidebar":"sam","previous":{"title":"ioport","permalink":"/docs/mcu/sam/sam-sam4s2a-ioport"}}');var t=A(74848),T=A(28453);const i={id:"sam-sam4s2a-adc",title:"SAM4S2A ADC",sidebar_label:"ADC",description:"SAM4S2A ADC",keywords:["SAM","ADC"]},a=void 0,C={},s=[{value:"ASF Wizard",id:"asf-wizard",level:2},{value:"Enum",id:"enum",level:2},{value:"Examples",id:"examples",level:2}];function D(_){const n={code:"code",h2:"h2",li:"li",pre:"pre",ul:"ul",...(0,T.R)(),..._.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"asf-wizard",children:"ASF Wizard"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"ADC - Analog-to-digital Converter (driver): The Analog to Digital Converter is able to capture analog signals and transform them into digital format with 10-bit or 12-bit resolution."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"enum",children:"Enum"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"/* The max ADC clock freq definition*/\n#define ADC_FREQ_MAX 20000000\n/* The min ADC clock freq definition*/\n#define ADC_FREQ_MIN 1000000\n/* The normal ADC startup time*/\n#define ADC_STARTUP_NORM 40\n/* The fast ADC startup time*/\n#define ADC_STARTUP_FAST 12\n\n/* Definitions for ADC resolution */\nenum adc_resolution_t {\n    ADC_10_BITS = ADC_MR_LOWRES_BITS_10, /* ADC 10-bit resolution */\n    ADC_12_BITS = ADC_MR_LOWRES_BITS_12  /* ADC 12-bit resolution */\n};\n\n/* Definitions for ADC trigger */\nenum adc_trigger_t {\n    /* Starting a conversion is only possible by software. */\n    ADC_TRIG_SW = ADC_MR_TRGEN_DIS,\n    /* External trigger */\n    ADC_TRIG_EXT = ADC_MR_TRGSEL_ADC_TRIG0 | ADC_MR_TRGEN,\n    /* TIO Output of the Timer Counter Channel 0 */\n    ADC_TRIG_TIO_CH_0 = ADC_MR_TRGSEL_ADC_TRIG1 | ADC_MR_TRGEN,\n    /* TIO Output of the Timer Counter Channel 1 */\n    ADC_TRIG_TIO_CH_1 = ADC_MR_TRGSEL_ADC_TRIG2 | ADC_MR_TRGEN,\n    /* TIO Output of the Timer Counter Channel 2 */\n    ADC_TRIG_TIO_CH_2 = ADC_MR_TRGSEL_ADC_TRIG3 | ADC_MR_TRGEN,\n    /* PWM Event Line 0 */\n    ADC_TRIG_PWM_EVENT_LINE_0 = ADC_MR_TRGSEL_ADC_TRIG4 | ADC_MR_TRGEN,\n    /* PWM Event Line 1 */\n    ADC_TRIG_PWM_EVENT_LINE_1 = ADC_MR_TRGSEL_ADC_TRIG5 | ADC_MR_TRGEN\n};\n\n/* Definitions for ADC channel number */\nenum adc_channel_num_t {\n    ADC_CHANNEL_0          = 0,\n    ADC_CHANNEL_1          = 1,\n    ADC_CHANNEL_2          = 2,\n    ADC_CHANNEL_3          = 3,\n    ADC_CHANNEL_4          = 4,\n    ADC_CHANNEL_5          = 5,\n    ADC_CHANNEL_6          = 6,\n    ADC_CHANNEL_7          = 7,\n    ADC_CHANNEL_8          = 8,\n    ADC_CHANNEL_9          = 9,\n    ADC_CHANNEL_10         = 10,\n    ADC_CHANNEL_11         = 11,\n    ADC_CHANNEL_12         = 12,\n    ADC_CHANNEL_13         = 13,\n    ADC_CHANNEL_14         = 14,\n    ADC_TEMPERATURE_SENSOR = 15,\n};\n\n/* Definitions for ADC gain value */\nenum adc_gainvalue_t {\n    ADC_GAINVALUE_0 = 0,\n    ADC_GAINVALUE_1 = 1,\n    ADC_GAINVALUE_2 = 2,\n    ADC_GAINVALUE_3 = 3\n};\n\n/* Definitions for ADC analog settling time */\nenum adc_settling_time_t {\n    ADC_SETTLING_TIME_0 = ADC_MR_SETTLING_AST3,\n    ADC_SETTLING_TIME_1 = ADC_MR_SETTLING_AST5,\n    ADC_SETTLING_TIME_2 = ADC_MR_SETTLING_AST9,\n    ADC_SETTLING_TIME_3 = ADC_MR_SETTLING_AST17\n};\n\n/** Definitions for ADC Start Up Time */\nenum adc_startup_time {\n    ADC_STARTUP_TIME_0  = ADC_MR_STARTUP_SUT0,\n    ADC_STARTUP_TIME_1  = ADC_MR_STARTUP_SUT8,\n    ADC_STARTUP_TIME_2  = ADC_MR_STARTUP_SUT16,\n    ADC_STARTUP_TIME_3  = ADC_MR_STARTUP_SUT24,\n    ADC_STARTUP_TIME_4  = ADC_MR_STARTUP_SUT64,\n    ADC_STARTUP_TIME_5  = ADC_MR_STARTUP_SUT80,\n    ADC_STARTUP_TIME_6  = ADC_MR_STARTUP_SUT96,\n    ADC_STARTUP_TIME_7  = ADC_MR_STARTUP_SUT112,\n    ADC_STARTUP_TIME_8  = ADC_MR_STARTUP_SUT512,\n    ADC_STARTUP_TIME_9  = ADC_MR_STARTUP_SUT576,\n    ADC_STARTUP_TIME_10 = ADC_MR_STARTUP_SUT640,\n    ADC_STARTUP_TIME_11 = ADC_MR_STARTUP_SUT704,\n    ADC_STARTUP_TIME_12 = ADC_MR_STARTUP_SUT768,\n    ADC_STARTUP_TIME_13 = ADC_MR_STARTUP_SUT832,\n    ADC_STARTUP_TIME_14 = ADC_MR_STARTUP_SUT896,\n    ADC_STARTUP_TIME_15 = ADC_MR_STARTUP_SUT960\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:'#include "conf_uart_serial.h"\n\n#include <asf.h>\n\nvoid serial_init(void) {\n    pio_configure(\n        PINS_USART0_PIO, PINS_USART0_TYPE, PINS_USART0_MASK, PINS_USART0_ATTR);\n    pmc_enable_periph_clk(USART_SERIAL_ID);\n    sysclk_enable_peripheral_clock(USART_SERIAL_ID);\n\n    const usart_serial_options_t usart_serial_options\n        = {.baudrate   = USART_SERIAL_BAUDRATE,\n           .charlength = USART_SERIAL_CHAR_LENGTH,\n           .paritytype = USART_SERIAL_PARITY,\n           .stopbits   = USART_SERIAL_STOP_BIT};\n\n    stdio_serial_init(USART_SERIAL, &usart_serial_options);\n}\n\nvoid adc_setup(void) {\n    pmc_enable_periph_clk(ID_ADC);\n\n    adc_init(ADC, F_CPU, 6400000, ADC_STARTUP_TIME_8);\n    adc_configure_timing(ADC, 0, ADC_SETTLING_TIME_3, 1);\n    adc_set_resolution(ADC, ADC_MR_LOWRES_BITS_10);\n    // print\n    adc_check(ADC, F_CPU);\n\n    adc_disable_all_channel(ADC);\n    adc_enable_channel(ADC, ADC_CHANNEL_0);\n    adc_enable_channel(ADC, ADC_CHANNEL_2);\n\n    adc_configure_trigger(ADC, ADC_TRIG_SW, 0);\n\n    adc_start(ADC);\n}\n\nint main(void) {\n    sysclk_init();\n    board_init();\n    /* Insert application code here, after the board has been initialized. */\n    wdt_disable(WDT);\n\n    serial_init();\n\n    adc_setup();\n\n    for(;;) {\n        if(adc_get_channel_status(ADC, ADC_CHANNEL_0)\n           && adc_get_channel_status(ADC, ADC_CHANNEL_2)) {\n            printf("%d,%d\\n",\n                   adc_get_channel_value(ADC, ADC_CHANNEL_0),\n                   adc_get_channel_value(ADC, ADC_CHANNEL_2));\n            adc_start(ADC);\n        }\n    }\n}\n'})})]})}function r(_={}){const{wrapper:n}={...(0,T.R)(),..._.components};return n?(0,t.jsx)(n,{..._,children:(0,t.jsx)(D,{..._})}):D(_)}},28453:(_,n,A)=>{A.d(n,{R:()=>i,x:()=>a});var e=A(96540);const t={},T=e.createContext(t);function i(_){const n=e.useContext(T);return e.useMemo((function(){return"function"==typeof _?_(n):{...n,..._}}),[n,_])}function a(_){let n;return n=_.disableParentContext?"function"==typeof _.components?_.components(t):_.components||t:i(_.components),e.createElement(T.Provider,{value:n},_.children)}}}]);